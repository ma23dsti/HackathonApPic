import streamlit as st
#from streamlit_datetime_range_picker import datetime_range_picker
from datetime import timedelta
import pandas as pd



def create_checkbox_group(options):
    """
    G√©n√®re dynamiquement un groupe de cases √† cocher (checkbox) dans Streamlit √† partir d‚Äôun dictionnaire d‚Äôoptions.

    Chaque cl√© du dictionnaire devient la cl√© d'√©tat dans st.session_state,
    et chaque valeur devient l‚Äô√©tiquette visible dans l‚Äôinterface utilisateur.

    Param√®tre :
        options (dict) : Dictionnaire {cl√©: √©tiquette} repr√©sentant les options √† afficher sous forme de cases √† cocher.

    R√©sultat retourn√© :
        - dict : Dictionnaire {cl√©: bool√©en} indiquant pour chaque option si la case a √©t√© coch√©e ou non.
    """
    return {key: st.checkbox(label, key=key) for key, label in options.items()}



def selection_parametre(liste_unite, nb_modele):
    """
    G√®re l'affichage des param√®tres s√©lectionnables via checkbox et radio bouton,
    n√©cessaires pour l'affichage du graphe et du tableau.

    Param√®tres :
        liste_unite (list[str]): Liste des unit√©s √† afficher dans le bouton radio.
        nb_modele (int): Nombre de mod√®les disponibles (utile pour l'affichage ou non de la moyenne des predictions).
    Remarque :
        La liste des types de temps n‚Äôest pas pass√©e en param√®tre car l‚Äôoption est fig√©e 
        directement dans l‚Äôappel au bouton radio.

    Retourne:
        Tuple contenant les √©tats s√©lectionn√©s :
        - bool : Affichage des donn√©es d'entr√©e (coch√© ou non)
        - str : Type de temps s√©lectionn√© ('temps horaire' ou 'temps relatif', en minuscules)
        - bool : Affichage de l‚Äôensemble des pr√©dictions
        - bool : Affichage de la moyenne des pr√©dictions (False si un seul mod√®le)
        - str : Unit√© de mesure s√©lectionn√©e
       
    """

    # Mise en page avec 4 colonnes (ratios personnalis√©s)
    col1, col2, col3, col4 = st.columns([2, 1, 1, 1])

    # Colonne 1 : Affichage des donn√©es
    with col1:
        st.markdown("Les donn√©es üìä:")

        # Affichage des cases √† cocher pour les types de donn√©es
        checkboxes = create_checkbox_group({
            "affichage_modele_entree": "Donn√©es d'entr√©e",
            "affichage_ensemble_prediction": "Ensemble des pr√©dictions"
        })

        # Affichage conditionnel de la moyenne des pr√©dictions
        affichage_moyenne_prediction = (
            st.checkbox("Moyenne des pr√©dictions", key="affichage_moyenne_prediction") 
            if nb_modele > 1 else False
        )

    # Colonne 2 : Choix du type de temps
    with col2:
        st.markdown("Type de temps üìÖ:")
        choix_temps = st.radio("", ["Temps horaire", "Temps relatif"], key="choix_temps")
        choix_temps = choix_temps.strip().lower()  # normalisation du choix

    # Colonne 3 : Choix de l‚Äôunit√© de mesure
    with col3:
        st.markdown("Unit√© de mesure üìè:")
        choix_unite = st.radio("", liste_unite, key="choix_unite")

    # Retour des choix utilisateur
    return (
        checkboxes["affichage_modele_entree"],
        choix_temps,
        checkboxes["affichage_ensemble_prediction"],
        affichage_moyenne_prediction,
        choix_unite
    )

def selection_min_max_choix_temps(choix_temps, df_final,df_donnees_entrees,df_prediction):
    """
    D√©termine les dates ou valeur minimum et maximum √† afficher dans le s√©lecteur de plage temporelle,
    en fonction du type de temps choisi par l'utilisateur.

    Param√®tres :
        choix_temps (str) : Type de temps s√©lectionn√© ('temps horaire' ou 'temps relatif').
        df_final (pd.DataFrame) : Donn√©es combin√©es (entr√©es et pr√©dictions).
        df_donnees_entrees (pd.DataFrame) : Donn√©es d'entr√©e uniquement.
        df_prediction (pd.DataFrame) : Donn√©es de pr√©diction uniquement.

    R√©sultats retourn√©s :
        - datetime ou int : Date/valeur minimale du jeu de donn√©es global.
        - datetime ou int : Date/valeur maximale du jeu de donn√©es global.
        - datetime ou int : Date/valeur minimale des donn√©es d'entr√©e.
        - datetime ou int : Date/valeur maximale des donn√©es d'entr√©e.
        - datetime ou int : Date/valeur minimale des pr√©dictions.
        - datetime ou int : Date/valeur maximale des pr√©dictions.
    """
    if choix_temps == "temps horaire":
        min_date = df_final[choix_temps].min().to_pydatetime()
        max_date = df_final[choix_temps].max().to_pydatetime()
        min_date_entree = df_donnees_entrees[choix_temps].min().to_pydatetime()  # date min des entr√©es
        max_date_entree = df_donnees_entrees[choix_temps].max().to_pydatetime()  # date max des entr√©es
        min_date_prediction = df_prediction[choix_temps].min()  # date min pr√©dictions
        max_date_prediction = df_prediction[choix_temps].max()  # date max pr√©dictions
    else:
        min_date = df_final[choix_temps].min()
        max_date = df_final[choix_temps].max()
        min_date_entree = df_donnees_entrees[choix_temps].min()
        max_date_entree = df_donnees_entrees[choix_temps].max()
        min_date_prediction = df_prediction[choix_temps].min() 
        max_date_prediction = df_prediction[choix_temps].max()
    
    return min_date, max_date, min_date_entree, max_date_entree ,min_date_prediction ,max_date_prediction

    
def selection_plage_date(min_date, max_date, choix_temps):
    """
    Affiche un curseur (slider) interactif permettant de s√©lectionner une plage temporelle
    en fonction des valeurs du type de temps choisi : temps horaire (datetime) ou temps relatif (entier).

    Param√®tres :
        min_date (datetime ou int) : Valeur minimale √† afficher dans le slider.
        max_date (datetime ou int) : Valeur maximale √† afficher dans le slider.
        choix_temps (str) : Type de temps s√©lectionn√© par l'utilisateur ('temps horaire' ou 'temps relatif').

    R√©sultats retourn√©s :
        - datetime ou int : Date/valeur de d√©but s√©lectionn√©.
        - datetime ou int : Date/valeur de fin s√©lectionn√©.
    """
   
    # param√®tres du slider selon choix_temps
    if choix_temps == "temps horaire":
        step = timedelta(seconds=1)
        slider_format = "YYYY-MM-DD HH:mm:ss"
    else:
        step = 1
        slider_format = None
    debut_date, fin_date = st.slider(
        "",
        min_value=min_date,
        max_value=max_date,
        #step=timedelta(seconds=1), # fig√©e √† 1 car c'est la p√©riodicit√© que nous avons pris - pour la rendre dynamique cf fichier resultats.json periodicite_mesure
        #format="YYYY-MM-DD HH:mm:ss",
        format=slider_format if slider_format else None,
        step=step,
        key="selection_date"  # synchronisation automatique
    )
   

    return debut_date, fin_date


def generer_listes_modeles(selection_options, id_modele_entree, id_modele_moyen, liste_modeles_id):
    """
    G√©n√®re dynamiquement les listes de mod√®les √† afficher selon les options s√©lectionn√©es par l'utilisateur.

    Cette fonction permet de d√©terminer :
    - si les donn√©es d'entr√©e doivent √™tre affich√©es,
    - si la moyenne des pr√©dictions est activ√©e,
    - si l'ensemble des mod√®les est s√©lectionn√©.

    Param√®tres :
        selection_options (dict) : Dictionnaire contenant les options d'affichage s√©lectionn√©es
                                   ( "affichage_modele_entree", "affichage_moyenne_prediction", etc.).
        id_modele_entree (list[str]) : Identifiant(s) des donn√©es d'entr√©e.
        id_modele_moyen (list[str]) : Identifiant du mod√®le moyen.
        liste_modeles_id (list[str]) : Liste des identifiants des mod√®les de pr√©diction.

    R√©sultats retourn√©s :
        - list[str] : Liste combin√©e des identifiants √† afficher (entr√©e, moyenne, ensemble).
        - list[str] : Liste contenant uniquement l‚Äôidentifiant du mod√®le moyen (ou vide si non s√©lectionn√©).
        - list[str] : Liste des identifiants des mod√®les de pr√©diction (ou vide si non s√©lectionn√©s).
    """
    modele_moyen = id_modele_moyen if selection_options["affichage_moyenne_prediction"] else []
    liste_modele_ensemble = liste_modeles_id if selection_options["affichage_ensemble_prediction"] else []
    liste_modele_entree = id_modele_entree if selection_options["affichage_modele_entree"] else []

    liste_donnees_filtre = liste_modele_entree + modele_moyen + liste_modele_ensemble
    return liste_donnees_filtre, modele_moyen, liste_modele_ensemble


def filtrer_df_final(df_final, var_id, choix_unite, choix_temps, selection_date, liste_donnees_filtre):
    """
    Filtre le DataFrame principal (`df_final`) en fonction des param√®tres s√©lectionn√©s par l'utilisateur :
    - les identifiants des mod√®les ou donn√©es d‚Äôentr√©e √† afficher,
    - l‚Äôunit√© de mesure choisie,
    - la p√©riode temporelle s√©lectionn√©e.

    Param√®tres :
        df_final (pd.DataFrame) : DataFrame global contenant les donn√©es d'entr√©e et de pr√©diction.
        var_id (str) : Nom de la colonne identifiant chaque s√©rie (mod√®le ou entr√©e).
        choix_unite (str) : Unit√© de mesure s√©lectionn√©e.
        choix_temps (str) : Type de temps s√©lectionn√©.
        selection_date (tuple) : Tuple contenant les bornes inf√©rieure et sup√©rieure du temps s√©lectionn√©.
        liste_donnees_filtre (list[str]) : Liste des identifiants des modeles s√©lectionn√©s

    R√©sultat retourn√© :
        - pd.DataFrame : Sous-ensemble filtr√© de `df_final` r√©pondant aux crit√®res s√©lectionn√©s.
    """

    #st.write("choix_temps :", choix_temps)
    #st.write(" type de selection_date[0] :", type(selection_date[0]))
    #st.write(" valeur selection_date[0] :", selection_date[0])

    # identification des bornes_temps inf et max
    if choix_temps == "temps horaire":
        borne_temps_inf = selection_date[0]
        borne_temps_sup = selection_date[1]
    else:
        borne_temps_inf = int(selection_date[0])
        borne_temps_sup = int(selection_date[1])

    # Filtrage des donn√©es
    df_final_selection = df_final[
        (df_final[var_id].isin(liste_donnees_filtre)) &
        (df_final['unite mesure'] == choix_unite) &
        (df_final[choix_temps] >= borne_temps_inf) &
        (df_final[choix_temps] <= borne_temps_sup)
    ]
    
    return df_final_selection

def verifier_modele_exclus(df_final_selection, liste_donnees_filtre, modele_moyen, liste_modele_ensemble):
    """
    V√©rifie si la s√©lection temporelle a entra√Æn√© l‚Äôexclusion de certaines donn√©es (entr√©e ou pr√©dictions).

    Si une ou plusieurs s√©ries ont √©t√© exclues (c‚Äôest-√†-dire absentes du DataFrame filtr√©),
    un message d‚Äôalerte est affich√© dans l‚Äôinterface utilisateur avec un message toast.
    Cette fonction met √©galement √† jour les listes de mod√®les pour √©viter tout affichage incoh√©rent.

    Param√®tres :
        df_final_selection (pd.DataFrame) : Donn√©es filtr√©es selon la plage temporelle.
        liste_donnees_filtre (list[str]) : Liste initiale des identifiants de modele devant √™tre affich√©s.
        modele_moyen (list[str]) : Identifiant du mod√®le moyen, s'il √©tait s√©lectionn√©.
        liste_modele_ensemble (list[str]) : Liste des identifiants des mod√®les de pr√©diction.

    R√©sultats retourn√©s :
        - list[str] : Liste mise √† jour des identifiants r√©ellement pr√©sents dans la s√©lection.
        - list[str] : Liste actualis√©e du mod√®le moyen (vide si exclu).
        - list[str] : Liste actualis√©e des mod√®les de pr√©diction (vide si exclus).
    """
    liste_modele_filtre_selection = df_final_selection['id donnee'].unique().tolist()
    if set(liste_modele_filtre_selection) != set(liste_donnees_filtre):
        if set(liste_modele_filtre_selection) == set(modele_moyen + liste_modele_ensemble):
            st.toast("Les donn√©es d'entr√©e ont √©t√© exclues par votre s√©lection temporelle.", icon="‚ö†Ô∏è")
        elif not liste_modele_filtre_selection:  # liste compl√®tement vide
            st.toast("Toutes les donn√©es ont √©t√© exclues par votre s√©lection temporelle.", icon="‚ö†Ô∏è")
        else:
            st.toast("Les donn√©es de pr√©diction ont √©t√© exclues par votre s√©lection temporelle.", icon="‚ö†Ô∏è")
            modele_moyen = []
            liste_modele_ensemble = []
    
    return liste_modele_filtre_selection, modele_moyen, liste_modele_ensemble

def selection_variable_filtre(id_modele_entree, selection_options, selection_date, df_final, donnees_kpi,
                               liste_modeles_id, var_id, id_modele_moyen, choix_unite, choix_temps):
    """
    Filtre les donn√©es d‚Äôentr√©e, les pr√©dictions et les KPI selon les param√®tres s√©lectionn√©s 
    par l‚Äôutilisateur.

    Cette fonction applique une s√©rie d'√©tapes :
    1. G√©n√®re la liste des identifiants de donn√©es √† afficher (entr√©e, moyenne, pr√©dictions).
    2. Filtre les donn√©es globales `df_final` en fonction de ces identifiants, de l‚Äôunit√© et du temps.
    3. V√©rifie si certaines donn√©es ont √©t√© exclues (par exemple √† cause de la plage temporelle).
    4. Filtre les KPI en fonction des mod√®les restants (hors donn√©es d‚Äôentr√©e).

    Param√®tres :
        id_modele_entree (list[str]) : Identifiant des donn√©es d‚Äôentr√©e.
        selection_options (dict) : Dictionnaire contenant les options de s√©lection activ√©es.
        selection_date (tuple) : Plage temporelle s√©lectionn√©e par l‚Äôutilisateur.
        df_final (pd.DataFrame) : Donn√©es compl√®tes √† filtrer (entr√©e + pr√©dictions).
        donnees_kpi (list[dict]) : Liste des indicateurs de performance par mod√®le.
        liste_modeles_id (list[str]) : Liste de tous les mod√®les disponibles.
        var_id (str) : Nom de la colonne identifiant les modeles
        id_modele_moyen (list[str]) : Identifiant du mod√®le moyen.
        choix_unite (str) : Unit√© de mesure s√©lectionn√©e.
        choix_temps (str) : Type de temps s√©lectionn√©.

    R√©sultats retourn√©s :
        - pd.DataFrame : Donn√©es filtr√©es √† afficher dans le graphique.
        - pd.DataFrame : Donn√©es KPI filtr√©es √† afficher dans le tableau.
        - list[str] : Liste finale des modeles apr√®s filtrage.
    """

    # √âtape 1 : d√©terminer les mod√®les √† afficher
    liste_donnees_filtre, modele_moyen, liste_modele_ensemble = generer_listes_modeles(
        selection_options, id_modele_entree, id_modele_moyen, liste_modeles_id
    )

    # √âtape 2 : filtrer les donn√©es
    df_final_selection = filtrer_df_final(
        df_final, var_id, choix_unite, choix_temps, selection_date, liste_donnees_filtre
    )

    # √âtape 3 : g√©rer les exclusions dues √† la plage temporelle
    liste_donnees_filtre, modele_moyen, liste_modele_ensemble = verifier_modele_exclus(
        df_final_selection, liste_donnees_filtre, modele_moyen, liste_modele_ensemble
    )

    # √âtape 4 : filtrage des donn√©es KPI
    df_kpi = pd.DataFrame(donnees_kpi)
    if modele_moyen + liste_modele_ensemble:
        df_kpi_selection = df_kpi[df_kpi[var_id].isin(modele_moyen + liste_modele_ensemble)]
    else:
        df_kpi_selection = pd.DataFrame(columns=df_kpi.columns)

    return df_final_selection, df_kpi_selection, liste_donnees_filtre



def selection_titre(selection_options, choix_temps, liste_unite, choix_unite):
   
    """
    G√©n√®re dynamiquement le titre du graphique ainsi que les √©tiquettes des axes,
    en fonction des donn√©es s√©lectionn√©es par l‚Äôutilisateur.

    Le titre est construit √† partir des √©l√©ments coch√©s :
    - donn√©es d'entr√©e
    - ensemble des pr√©dictions
    - moyenne des pr√©dictions

    Param√®tres :
        selection_options (dict) : Dictionnaire contenant les √©tats des options s√©lectionn√©es par l'utilisateur.
        choix_temps (str) : Type de temps utilis√© pour l'axe des abscisses ('temps horaire' ou 'temps relatif').
        liste_unite (list[str]) : Liste des unit√©s disponibles (non utilis√©e ici, mais transmise pour coh√©rence).
        choix_unite (str) : Unit√© de mesure s√©lectionn√©e.

    R√©sultats retourn√©s :
        - str : Titre complet. (√©tait affich√© au dessus du graphe mais plus utilis√©)
        - str : Libell√© de l‚Äôaxe des X.
        - str : Libell√© de l‚Äôaxe des Y (incluant l‚Äôunit√©).
    """

    # Construction du titre du graphique
    titre_parts = []
    if selection_options["affichage_modele_entree"]:
        titre_parts.append("Donn√©es d'entr√©e")
    if selection_options["affichage_ensemble_prediction"]:
        titre_parts.append("Ensemble des Pr√©dictions")
    if selection_options["affichage_moyenne_prediction"]:
        titre_parts.append("Moyenne des Pr√©dictions")

    titre_graphe = "Graphique des " + ", ".join(titre_parts)

    

    # Labels des axes
    label_x = choix_temps
    #label_y = f"{choix_format} {choix_unite}"
    label_y = f" {choix_unite}" # plotly affiche les axes en KMGT

    return titre_graphe, label_x, label_y

def selection_donnees_format_export():
    """
    Affiche dans l‚Äôinterface Streamlit deux groupes de cases √† cocher :
    - les types de donn√©es √† exporter (pr√©dictions, m√©triques),
    - les formats d‚Äôexportation (CSV, PDF, PNG).

    R√©sultat retourn√© :
        - dict : Dictionnaire contenant deux sous-dictionnaires :
            - "donnees" : {cl√©: bool√©en} pour chaque type de donn√©e s√©lectionn√©e.
            - "formats" : {cl√©: bool√©en} pour chaque format d‚Äôexport s√©lectionn√©.
    """
    col1, col2, col3 = st.columns([1,1,2])  # col1:1/4 ...

    with col1:
        st.write("Les donn√©es üìä:")

        # Checkbox pour les donn√©es √† exporter
        donnees_options = create_checkbox_group({
            "export_prediction": "Donn√©es des pr√©dictions",
            "export_kpi": "M√©triques"
        })

    with col2:
        st.write("Les formats üìÇ:")

        # Checkbox pour les formats d'export
        format_options = create_checkbox_group({
            "export_format_csv": "CSV",
            "export_format_pdf": "PDF",
            "export_format_png": "PNG"
        })

    # 
    return {
        "donnees": donnees_options,
        "formats": format_options
    }



